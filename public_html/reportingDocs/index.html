<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Reporting Dashboard</title>
  <script src="https://cdn.zingchart.com/zingchart.min.js"></script>
  <script src="https://cdn.zinggrid.com/zinggrid.min.js" defer></script>  
  <link rel="icon" href="/favicon.png" type="image/png" />
  <link href="https://fonts.googleapis.com/css2?family=Comfortaa&display=swap" rel="stylesheet" />
  <style>
    
    /* Here  we build the page, using the CSS styles that are present on my other pages*/
    body {
      background-color: green;
      color: white;
      margin: 0;
      padding: 0;
      font-family: 'Comfortaa', sans-serif;
    }
    h1.mainTitle {
      background-color: #db5079;
      padding: 1.5rem;
      text-align: center;
      color: white;
    }
    /* Here we add some chart characteristics, for instance setting sizes, their background colors, margins, etc. */
    .chart-container {
      width: 60%;
      height: 450px;
      margin: 2rem auto;
      background: #fc8eac;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.25);
    }
    .chart-title {
      text-align: center;
      color: white;
      font-weight: bold;
      margin-bottom: 1rem;
      font-size: 24px;
    }
    .chart {
      width: 100%;
      height: 400px;
    }

    zing-grid#errorGrid {
      height: 400px;
      overflow: auto; /* Enables horizontal and vertical scrolling */
      margin: 2rem auto 3rem;
      width: 90vw; /* responsive width, adjust as needed */
      font-family: 'Comfortaa', sans-serif;
    }

    /* Caption style like your example */
    zing-grid#errorGrid zg-caption {
      background-color: #fc8eac;
      color: white;
      padding: 1rem;
      font-weight: bold;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1 class="mainTitle">Reporting Dashboard</h1>

  <!-- We actually make the functions to pull up our various charts/grid -->
  <div class="chart-container">
    <div class="chart-title">Network Type Chart</div>
    <div id="networkTypeChart" class="chart"></div>
  </div>

  <div class="chart-container">
    <div class="chart-title">Day Activity Chart</div>
    <div id="timeOfDayChart" class="chart"></div>
  </div>

  <!-- We define the formatting for our grid, specifically the columns and page layout -->
  <zing-grid
    id="errorGrid"
    pager
    page-size="5"
    page-size-options="5, 10, 15"
    style="font-family: Comfortaa;">
    <zg-caption>Errors Per Page Grid</zg-caption>
    <zg-colgroup>
      <zg-column header="Page URL" index="url" type="text"></zg-column>
      <zg-column header="Error Type" index="type" type="text"></zg-column>
      <zg-column header="Occurrences" index="occurrences" type="number" align="center"></zg-column>
      <zg-column header="Severity" index="severity" type="text" align="center"></zg-column>
    </zg-colgroup>
  </zing-grid>

  <script>

    // This helps us fetch all the data from our static/performance/activity collections and then store them here for easy indexing/access
    Promise.all([
      fetch('https://satvikammula.site/api/static').then(r => r.json()),
      fetch('https://satvikammula.site/api/performance').then(r => r.json()),
      fetch('https://satvikammula.site/api/activity').then(r => r.json())
    ]).then(([staticData, performanceData, activityData]) => {
      const networkSessionIDs = new Set();
      const networkCounts = {
        'wifi': 0,
        '4g': 0,
        '5g': 0,
        'unknown': 0
      };

      // Here we keep track of how many users are attributed to using a certain network
      staticData.forEach(entry => {
        // We make sure same sessions aren't repeated
        if(!networkSessionIDs.has(entry.userSessionID)) {
          networkSessionIDs.add(entry.userSessionID)
          const type = entry.userNetworkConnection ? entry.userNetworkConnection.toLowerCase() : 'unknown';
          // If the user's network is known, we save or its unknown
          if (networkCounts.hasOwnProperty(type)) {
            networkCounts[type]++;
          } else {
            networkCounts['unknown']++;
          }
        }
      });

      // Here we create the labels for our chart, and add an array to track the counts of each network type
      const networkLabels = ['WiFi', '4G', '5G', 'Unknown'];
      const networkValues = [
        networkCounts['wifi'],
        networkCounts['4g'],
        networkCounts['5g'],
        networkCounts['unknown']
      ];

      // Here, we map together each networkLabel with its corresponding values
      const paired = networkLabels.map((label, i) => {
        return { label: label, value: networkValues[i] };
      });

      // We sort so that the buckets go from largest to smallest
      paired.sort((a, b) => a.value - b.value);

      // We sort our arrays
      const sortedLabels = paired.map(p => p.label);
      const sortedValues = paired.map(p => p.value);

      // We calculate the percentages on the buckets, just to be more informative to the user
      const total = sortedValues.reduce((a,b)=>a+b,0);
      const percentLabels = sortedValues.map(v => `${Math.round((v / total) * 100)}%`);

      // We render our horizontal bar chart
      zingchart.render({
        id: 'networkTypeChart',
        data: {
          title: {
            text: 'Users per Network Connection Type',
            fontFamily: 'Comfortaa',
            fontSize: 16,
            fontColor: 'black',
            fontWeight: 'bold'
          },
          type: 'hbar',
          series: [{
            values: sortedValues,
            backgroundColor: ['#9B3192', '#B14EBB','#6A1B72','#D08ED7'],
            text: "Users",
            valueBox: {
              placement: 'middle',
              fontColor: 'white',
              fontFamily: 'Comfortaa',
              fontSize: 12,
              rules: percentLabels.map((label, index) => ({
                rule: `%i == ${index}`,
                text: label
              }))
            },
          }],
          // Though it says scaleX, we are technically setting the y-axis for our horizonal bar chart
          scaleX: {
            labels: sortedLabels,
            label: {
              text: 'Network Type',
              fontFamily: 'Comfortaa',
              fontSize: 14,
              fontColor: 'black'
            },
            item: {
              fontFamily: 'Comfortaa',
              fontSize: 13,
              fontColor: 'black'
            }
          },
          // Though it says scaleY, we are technicaly setting the x-axis for our horizonal bar chart
          scaleY: {
            label: {
              text: 'Number of Users',
              fontFamily: 'Comfortaa',
              fontSize: 14,
              fontColor: 'black'
            },
            item: {
              fontFamily: 'Comfortaa',
              fontSize: 14,
              fontColor: 'black'
            }
          },
          plot: {
            barsSpaceLeft: 0.15,
            barsSpaceRight: 0.15,
            barWidth: "50%",
            tooltip: {
              fontFamily: 'Comfortaa',
              text: "%t: %v"
            }
          },
          plotarea: {
            margin: '65px 40px 60px 120px'
          },
          // We add a subtitle as a customization choice, so we can ensure the audience trusts us
          subtitle: {
            text: `Sample size: ${networkSessionIDs.size} sessions`,
            fontFamily: 'Comfortaa',
            fontSize: 10,
            fontColor: "black"
          }
        },
        height: '400px',
        width: '100%'
      });

      // This method is used to extract the hour value from our timestamp in activity data
      function calculateHour(timestamp) {
        // We parse the timestamp
        const parts = timestamp.split(', ');
        const timePiece = parts[1];
        [time, ampm] = timePiece.split(' ');
        let [hours, minutes, seconds] = time.split(':').map(Number);
        // We save the hour under military time for ease
        if (ampm === 'PM' && hours !== 12) {
          hours += 12;
        }
        if (ampm === 'AM' && hours === 12) {
          hours = 0;
        }
        return hours;
      }

      // We keep track of the engagement events per hour
      const hourlyCounts = Array(24).fill(0);
      let activityCount = 0
      let specialCount = 0
      activityData.forEach(entry => {
        // We make sure the activity is actually an activity
        if(entry.userAction!=="idleBreak" && entry.userAction!=="pageEnter" && entry.userAction!=="pageLeave" && entry.userAction!="error") {
          const hour = calculateHour(entry.timestamp);
          // We do some extra tracking for outputting the peak
          if(hour===21) {
            specialCount+=1;
          }
          // We track the amount of engagement per hour and the total engagments we have
          hourlyCounts[hour]++;
          activityCount+=1;
        }
      });

      // We actually render the chart
      zingchart.render({
        id: 'timeOfDayChart',
        data: {
          type: 'line',
          title: {
            text: 'Hourly Site Engagement',
            fontFamily: 'Comfortaa',
            fontSize: 16,
            fontColor: "black",
            fontWeight: 'bold',
          },
          // We keep a subtitle so that the audience trusts the data more
          subtitle: {
            text: `Based on ${activityCount} user actions`,
            fontFamily: 'Comfortaa',
            fontSize: 10,
            fontColor: "black"
          },
          series: [{
            values: hourlyCounts,
            text: 'User Actions',
            lineColor: '#B14EBB',
            lineWidth: 3,
            marker: {
              backgroundColor: '#B14EBB',
              borderColor: 'white',
              size: 4
            }
          }],
          // We set the x-axis as the hours in the day
          scaleX: {
            label: {
              text: 'Hour of Day (0â€“23)',
              fontFamily: 'Comfortaa',
              fontSize: 14,
              fontColor: 'black'
            },
            labels: [...Array(24).keys()],
            item: {
              fontFamily: 'Comfortaa',
              fontSize: 12,
              fontColor: 'black'
            },
            // We add a grid just as a visual treat
            guide: {
              visible: true,
              lineStyle: 'solid',
              lineColor: '#ccc',
              lineWidth: 1
            }
          },
          // We set the y-axis as the number of engagement events
          scaleY: {
            label: {
              text: 'Number of Engagement Events',
              fontFamily: 'Comfortaa',
              fontSize: 14,
              fontColor: 'black'
            },
            item: {
              fontFamily: 'Comfortaa',
              fontSize: 12,
              fontColor: 'black'
            }
          },
          // We allow for hovering so that the audience can see the exact/raw values
          tooltip: {
            text: "Hour %i: %v actions",
            fontFamily: 'Comfortaa'
          },
          plotarea: {
            margin: '60px 40px 60px 100px'
          },
          // We integrate a little text box to showcase the peak, specifically for the audience
          labels: [
            {
              text: `Peak at hour ${21} with ${specialCount} actions`,
              fontFamily: 'Comfortaa',
              fontSize: 9,
              fontColor: 'white',
              backgroundColor: '#B14EBB',
              padding: 5,
              borderRadius: 4,
              callout: true,
              calloutHeight: 10,
              calloutWidth: 15,
              hook: `node:plot=0;index=${21}`,
              offsetX: -82,
              offsetY: -33,
              anchor: 'auto'
            }
          ]
        },
        height: '400px',
        width: '100%'
      });

      // We make a map of the errors so we know what error is occuring, where, what kind, and how often
      const errorMap = {};

      activityData.forEach(entry => {
        // We make sure we are actually looking at errors
        if (entry.userAction === 'error') {
          const key = `${entry.errorLocation}|${entry.errorMessage}`;
          if (!errorMap[key]) {
            errorMap[key] = {
              // We track the page of the error, the type, and how often it occurred
              url: entry.errorLocation || 'Unknown',
              type: entry.errorMessage || 'Unknown Error',
              occurrences: 0,
            };
          }
          // We make sure to track how many times it happens
          errorMap[key].occurrences += 1;
        }
      });

      // We store how severe the error is, just as extra info to the user
      const getSeverity = (msg, count) => {
        const msgLower = msg.toLowerCase();
        if (msgLower.includes("referenceerror") || count > 10) return "High";
        if (msgLower.includes("typeerror") || count > 5) return "Medium";
        return "Low";
      };

      // We add colors to the severity variables, just to visually dictate it to the audience
      const getSeverityColor= (severity) => {
        let color = '#7f8c8d';
        if (severity === 'High') color = '#e74c3c';
        else if (severity === 'Medium') color = '#f39c12';
        else if (severity === 'Low') color = '#27ae60';

        return `<span style="color: ${color}; font-weight: bold;">${severity}</span>`;
      };

      // We create a whole object array kind of carrying all our rows
      // Used by Zinggrid for charting
      const errorArray = Object.values(errorMap).map(entry => ({
        url: entry.url,
        type: entry.type,
        occurrences: entry.occurrences,
        severity: getSeverityColor(getSeverity(entry.type, entry.occurrences))
      }));

      // We sort our chart by the most occuring error (severe) to least
      errorArray.sort((a,b) => b.occurrences-a.occurrences)
      document.getElementById('errorGrid').data = errorArray;
    }).catch(err => console.error("Error fetching data:", err));
    // We catch any errors if the data didn't fetch for some reason
  </script>
</body>
</html>